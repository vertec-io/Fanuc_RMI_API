# FANUC RMI v0.8.0 Architecture Redesign Specification

**Date**: 2025-12-01  
**Status**: ğŸ“‹ DRAFT  
**Author**: AI Assistant + Human Review

---

## ğŸ¯ Executive Summary

This specification outlines a major architectural redesign to transform the FANUC RMI web interface from a development/testing tool into a production-ready robot control system. The key changes address:

1. **Immediate Robot Control** - Pause/stop should halt motion instantly, not after buffered instructions complete
2. **Server-Side State** - Server is source of truth; clients observe/control shared state
3. **Robot Connection Management** - First-class robot connections with per-robot configuration
4. **Client Control Locking** - Only one client controls a robot at a time
5. **Complete I/O Coverage** - Digital, analog, and group I/O with configurable display
6. **Speed Override UI** - Expose SetOverride command in the interface

---

## ğŸ“Š Current State Analysis

### Current Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     WebSocket      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      RMI       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   web_app    â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  web_server  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Robot/Sim   â”‚
â”‚   (Client)   â”‚    JSON + bincode â”‚   (Server)   â”‚    bincode     â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                    â”‚
     â”‚ - Client owns program state        â”‚ - Passes through to robot
     â”‚ - Client requests execution        â”‚ - Single shared executor
     â”‚ - No client identification         â”‚ - No per-robot state
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Current Problems

| Problem | Impact |
|---------|--------|
| **Pause doesn't stop immediately** | Simulator/robot processes queued instructions before pausing |
| **Client-centric program state** | Refresh loses execution state; other clients don't see it |
| **No client control locking** | Multiple clients can send conflicting commands |
| **Single robot connection** | Can't switch between simulator and real robot easily |
| **Basic robot_connections table** | Only name/ip/port - no per-robot configuration |
| **No speed override UI** | Can't adjust robot speed from interface |
| **Limited I/O** | Only DIN/DOUT, no analog or group I/O |

---

## ğŸ—ï¸ Target Architecture

### High-Level Design

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              WEB SERVER (Source of Truth)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Client Manager  â”‚     â”‚           Robot Connection Manager              â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ - Client ID     â”‚     â”‚ Robot 1 (Simulator)    â”‚ Robot 2 (CRX-10)      â”‚  â”‚
â”‚  â”‚ - Control lock  â”‚     â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚ - Last activity â”‚     â”‚ â”‚ FanucDriver       â”‚  â”‚ â”‚ FanucDriver       â”‚ â”‚  â”‚
â”‚  â”‚ - Subscriptions â”‚     â”‚ â”‚ ProgramExecutor   â”‚  â”‚ â”‚ ProgramExecutor   â”‚ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ â”‚ ExecutionState    â”‚  â”‚ â”‚ ExecutionState    â”‚ â”‚  â”‚
â”‚           â”‚              â”‚ â”‚ I/O Config        â”‚  â”‚ â”‚ I/O Config        â”‚ â”‚  â”‚
â”‚           â”‚              â”‚ â”‚ Motion Defaults   â”‚  â”‚ â”‚ Motion Defaults   â”‚ â”‚  â”‚
â”‚           â”‚              â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚           â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚           â”‚                         â”‚                       â”‚                  â”‚
â”‚           â”‚                         â–¼                       â–¼                  â”‚
â”‚           â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚           â”‚              â”‚              SQLite Database                      â”‚ â”‚
â”‚           â”‚              â”‚  - robot_connections (with full config)          â”‚ â”‚
â”‚           â”‚              â”‚  - io_display_config (per connection)            â”‚ â”‚
â”‚           â”‚              â”‚  - programs                                       â”‚ â”‚
â”‚           â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  WebSocket    â”‚
    â”‚  Connections  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚   â”‚   â”‚
    â”Œâ”€â”€â”€â”€â”˜   â”‚   â””â”€â”€â”€â”€â”
    â–¼        â–¼        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚Client1â”‚ â”‚Client2â”‚ â”‚Client3â”‚
â”‚(ctrl) â”‚ â”‚(view) â”‚ â”‚(view) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ Component Specifications

### 1. Simulator Pause/Abort Fix

**Problem**: When pause is sent, the simulator's motion executor continues processing its mpsc queue.

**Solution**: Add abort/pause signaling to the simulator.

```rust
// sim/src/main.rs - New shared state
struct MotionExecutorState {
    paused: AtomicBool,
    abort_requested: AtomicBool,
    clear_queue_requested: AtomicBool,
}

// Motion executor loop modification
while let Some(cmd) = motion_rx.recv().await {
    // Check for abort before processing
    if state.abort_requested.load(Ordering::Relaxed) {
        // Clear remaining queue
        while motion_rx.try_recv().is_ok() {}
        state.abort_requested.store(false, Ordering::Relaxed);
        continue;
    }

    // Check for pause during motion interpolation
    for step in 1..=total_steps {
        while state.paused.load(Ordering::Relaxed) {
            tokio::time::sleep(Duration::from_millis(50)).await;
            // Check for abort during pause
            if state.abort_requested.load(Ordering::Relaxed) {
                break; // Exit interpolation loop
            }
        }
        // ... interpolation step ...
    }
}
```

**FRC_Pause Command**: Add handling for FRC_Pause command (currently only FRC_Abort exists).

---

### 2. Buffered Program Execution System

**Current Behavior**: All instructions sent at once, responses tracked.

**Target Behavior**: True buffered streaming matching FANUC RMI spec.

#### FANUC RMI Buffer Behavior (from B-84184EN_02):
- **Instruction Buffer**: Holds 8 packets concurrently (can send 8 ahead)
- **Ring Buffer**: Holds 200 instructions total
- **Return Packets**: Sent when instruction COMPLETES (not when received)
- **CNT Moves**: Don't execute until next motion arrives
- **NoBlend Flag**: After RMI v5, allows last CNT instruction to execute

#### Implementation:

```rust
// web_server/src/program_executor.rs

pub struct BufferedExecutor {
    /// Maximum instructions to send ahead
    const MAX_BUFFER: usize = 5, // Conservative: use 5 of 8 available slots

    /// Instructions waiting to be sent
    pending_queue: VecDeque<(usize, SendPacket)>,

    /// Instructions sent but not yet completed (line_number -> sequence_id)
    in_flight: HashMap<u32, usize>,

    /// Highest completed line number
    completed_line: usize,

    /// Execution state
    state: ExecutorState,
}

pub enum ExecutorState {
    Idle,
    Running { program_id: i64, total_lines: usize },
    Paused { program_id: i64, total_lines: usize, last_completed: usize },
    Stopping, // Draining in-flight before transitioning to Idle
    Error { message: String },
}

impl BufferedExecutor {
    /// Feed more instructions to maintain buffer level
    async fn fill_buffer(&mut self, driver: &FanucDriver) {
        while self.in_flight.len() < Self::MAX_BUFFER {
            if let Some((line, packet)) = self.pending_queue.pop_front() {
                if let Ok(request_id) = driver.send_packet(packet, PacketPriority::Standard) {
                    // Map will be updated when SentInstructionInfo arrives
                    // For now, just track that we've sent it
                }
            } else {
                break; // No more instructions to send
            }
        }
    }

    /// Handle instruction completion response
    async fn on_instruction_complete(&mut self, sequence_id: u32, error_id: u32) {
        if let Some(line_number) = self.in_flight.remove(&sequence_id) {
            if error_id != 0 {
                self.state = ExecutorState::Error {
                    message: format!("Line {} failed with error {}", line_number, error_id)
                };
                return;
            }

            self.completed_line = self.completed_line.max(line_number);

            // Fill buffer with next instruction
            self.fill_buffer().await;

            // Check for completion
            if self.pending_queue.is_empty() && self.in_flight.is_empty() {
                self.state = ExecutorState::Idle;
                // Broadcast completion
            }
        }
    }

    /// Pause execution (stops sending new instructions)
    fn pause(&mut self) {
        if let ExecutorState::Running { program_id, total_lines } = self.state {
            self.state = ExecutorState::Paused {
                program_id,
                total_lines,
                last_completed: self.completed_line
            };
            // Note: In-flight instructions will still complete
        }
    }

    /// Stop execution (abort robot + clear queues)
    async fn stop(&mut self, driver: &FanucDriver) {
        self.state = ExecutorState::Stopping;
        self.pending_queue.clear();
        // FRC_Abort clears the robot's buffer
        let _ = driver.abort().await;
        self.in_flight.clear();
        self.state = ExecutorState::Idle;
    }
}
```

---

### 3. Client Control Locking

**Concept**: Only one client can control a robot at a time. Other clients can observe.

```rust
// web_server/src/client_manager.rs

pub struct ClientSession {
    pub id: Uuid,
    pub connected_at: Instant,
    pub last_activity: Instant,
    pub subscribed_robots: HashSet<i64>, // robot_connection IDs
}

pub struct RobotControlLock {
    pub holder: Option<Uuid>,           // Client ID holding control
    pub acquired_at: Option<Instant>,
    pub last_activity: Option<Instant>,
}

impl RobotControlLock {
    const INACTIVITY_TIMEOUT: Duration = Duration::from_secs(600); // 10 minutes

    /// Try to acquire control
    pub fn try_acquire(&mut self, client_id: Uuid) -> Result<(), ControlError> {
        if let Some(holder) = self.holder {
            if holder == client_id {
                // Already holding
                self.last_activity = Some(Instant::now());
                return Ok(());
            }

            // Check for timeout
            if let Some(last) = self.last_activity {
                if last.elapsed() > Self::INACTIVITY_TIMEOUT {
                    // Timeout - allow takeover
                    let old_holder = self.holder.take();
                    // TODO: Notify old holder via WebSocket
                }
            }

            return Err(ControlError::AlreadyControlled {
                holder,
                can_request: true
            });
        }

        self.holder = Some(client_id);
        self.acquired_at = Some(Instant::now());
        self.last_activity = Some(Instant::now());
        Ok(())
    }

    /// Request control transfer
    pub fn request_transfer(&self, requester: Uuid) -> Result<(), ControlError> {
        // Notifies current holder of transfer request
        // Current holder can approve or deny
    }
}
```

**Client API Changes**:

```rust
// New ClientRequest variants
#[serde(rename = "request_control")]
RequestControl { robot_connection_id: i64 },

#[serde(rename = "release_control")]
ReleaseControl { robot_connection_id: i64 },

#[serde(rename = "transfer_control")]
TransferControl { robot_connection_id: i64, to_client_id: Uuid },

// New ServerResponse variants
#[serde(rename = "control_acquired")]
ControlAcquired { robot_connection_id: i64 },

#[serde(rename = "control_denied")]
ControlDenied { robot_connection_id: i64, reason: String, holder_id: Option<Uuid> },

#[serde(rename = "control_lost")]
ControlLost { robot_connection_id: i64, reason: String }, // Timeout, transfer, etc.

#[serde(rename = "control_requested")]
ControlRequested { robot_connection_id: i64, requester_id: Uuid },
```

---

### 4. Robot Connection Configuration (Database Schema)

**Current Schema**:
```sql
CREATE TABLE robot_connections (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    ip_address TEXT NOT NULL DEFAULT '127.0.0.1',
    port INTEGER NOT NULL DEFAULT 16001,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

**New Schema**:
```sql
-- Core robot connection info
CREATE TABLE robot_connections (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    ip_address TEXT NOT NULL DEFAULT '127.0.0.1',
    port INTEGER NOT NULL DEFAULT 16001,
    -- Connection behavior
    auto_connect BOOLEAN DEFAULT FALSE,     -- Connect on server start
    is_simulator BOOLEAN DEFAULT FALSE,     -- Visual indicator in UI
    -- Motion defaults (per-robot)
    default_speed REAL DEFAULT 100.0,
    default_speed_type TEXT DEFAULT 'mm/s', -- 'mm/s', '%', 'sec'
    default_term_type TEXT DEFAULT 'CNT',
    default_term_value INTEGER DEFAULT 100,
    default_uframe INTEGER DEFAULT 0,
    default_utool INTEGER DEFAULT 0,
    -- Orientation defaults
    default_w REAL DEFAULT 0.0,
    default_p REAL DEFAULT 0.0,
    default_r REAL DEFAULT 0.0,
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- I/O display configuration (per-robot, per-type)
CREATE TABLE io_display_config (
    id INTEGER PRIMARY KEY,
    robot_connection_id INTEGER NOT NULL,
    io_type TEXT NOT NULL,              -- 'DIN', 'DOUT', 'AIN', 'AOUT', 'GIN', 'GOUT'
    port_number INTEGER NOT NULL,
    display_name TEXT,                  -- 'Valve 1', 'Light 1', etc.
    display_order INTEGER DEFAULT 0,    -- Order in UI
    show_in_panel BOOLEAN DEFAULT TRUE, -- Show in right panel
    show_in_dashboard BOOLEAN DEFAULT TRUE, -- Show in Info tab
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (robot_connection_id) REFERENCES robot_connections(id) ON DELETE CASCADE,
    UNIQUE(robot_connection_id, io_type, port_number)
);

-- Server settings (not per-robot)
CREATE TABLE server_settings (
    id INTEGER PRIMARY KEY,
    key TEXT NOT NULL UNIQUE,
    value TEXT,
    description TEXT
);

-- Example server settings:
-- ('websocket_port', '9000', 'WebSocket server port')
-- ('auto_connect_on_startup', 'false', 'Connect to default robot on server start')
-- ('control_timeout_minutes', '10', 'Inactivity timeout for control lock')
```

---

### 5. Speed Override UI

**Implementation**:

```rust
// New ClientRequest
#[serde(rename = "set_speed_override")]
SetSpeedOverride { override_percent: u8 }, // 0-100

// Handler
pub async fn set_speed_override(driver: Arc<FanucDriver>, percent: u8) -> ServerResponse {
    let packet = SendPacket::Command(Command::FrcSetOverride {
        override_percent: percent.min(100)
    });
    match driver.send_packet(packet, PacketPriority::High) {
        Ok(_) => ServerResponse::Success {
            message: format!("Speed override set to {}%", percent)
        },
        Err(e) => ServerResponse::Error { message: e }
    }
}
```

**UI Component**:
- Slider in top bar or control panel (0-100%)
- Current override displayed from FRC_GetStatus response
- Quick buttons: 25%, 50%, 75%, 100%

---

### 6. Complete I/O Coverage

**I/O Types to Support**:

| Type | FANUC Command | Read | Write | Notes |
|------|---------------|------|-------|-------|
| DIN  | FRC_ReadDIN   | âœ“    | -     | Digital Input (1-256) |
| DOUT | FRC_WriteDOUT | âœ“    | âœ“     | Digital Output (1-256) |
| AIN  | FRC_ReadAIN   | âœ“    | -     | Analog Input (0-65535) |
| AOUT | FRC_WriteAOUT | âœ“    | âœ“     | Analog Output (0-65535) |
| GIN  | FRC_ReadGIN   | âœ“    | -     | Group Input (8-bit groups) |
| GOUT | FRC_WriteGOUT | âœ“    | âœ“     | Group Output (8-bit groups) |
| RIN  | FRC_ReadRIN   | âœ“    | -     | Robot Input |
| ROUT | FRC_WriteROUT | âœ“    | âœ“     | Robot Output |

**API Extensions**:
```rust
// ClientRequest additions
ReadAin { port_number: u16 },
WriteAout { port_number: u16, value: u16 },
ReadGin { group_number: u8 },
WriteGout { group_number: u8, value: u8 },

// ServerResponse additions
AinValue { port_number: u16, value: u16 },
AoutValue { port_number: u16, value: u16 },
GinValue { group_number: u8, value: u8 },
GoutValue { group_number: u8, value: u8 },
```

**Configurable I/O Panel**:
- Settings page allows configuring which I/O points to display
- Custom names per I/O point (e.g., "DIN 1" â†’ "Part Sensor")
- Right panel shows configured subset
- Dashboard Info tab shows full I/O grid

---

### 7. Settings Page Reorganization

**Current Structure**:
- Connection Settings (IP, Port, Connect button)
- Saved Connections (CRUD for robot_connections)
- Default Settings (motion defaults)
- Danger Zone (database reset)

**New Structure**:

```
Settings
â”œâ”€â”€ Server Settings
â”‚   â”œâ”€â”€ About (version, database location)
â”‚   â”œâ”€â”€ WebSocket Port
â”‚   â””â”€â”€ Danger Zone (database reset)
â”‚
â””â”€â”€ Robot Connections (first-class)
    â”œâ”€â”€ [+ Add Connection]
    â””â”€â”€ For each connection:
        â”œâ”€â”€ Basic Info (name, description, IP, port)
        â”œâ”€â”€ Connection Status (connected/disconnected, connect button)
        â”œâ”€â”€ Motion Defaults
        â”‚   â”œâ”€â”€ Default Speed / Speed Type
        â”‚   â”œâ”€â”€ Default Termination (CNT/FINE + value)
        â”‚   â””â”€â”€ Default UFrame / UTool
        â”œâ”€â”€ Orientation Defaults (W, P, R)
        â”œâ”€â”€ I/O Display Configuration
        â”‚   â”œâ”€â”€ Configure visible I/O points
        â”‚   â”œâ”€â”€ Set custom names
        â”‚   â””â”€â”€ Enable/disable for panel vs dashboard
        â””â”€â”€ âš ï¸ Delete Connection
```

---

### 8. Server-Side Program Execution

**Current Flow**:
```
Client â†’ "start_program" â†’ Server â†’ Load from DB â†’ Send all instructions â†’ Track responses
                                                    â†‘
                                         (Done synchronously, no shared state)
```

**New Flow**:
```
Client â†’ "start_program" â†’ Server â†’ Check control lock
                                  â†’ Load into RobotSession.executor
                                  â†’ Start buffered execution
                                  â†’ Broadcast state to all subscribed clients

Another Client â†’ "get_execution_status" â†’ Server returns shared state
                                        â†’ Can observe progress
```

**RobotSession Structure**:
```rust
pub struct RobotSession {
    pub connection_id: i64,
    pub driver: Option<Arc<FanucDriver>>,
    pub executor: BufferedExecutor,
    pub control_lock: RobotControlLock,
    pub subscribed_clients: HashSet<Uuid>,
    pub io_cache: IOCache,
    pub last_status: Option<FrcGetStatusResponse>,
}

impl RobotSession {
    /// Called when client connects and subscribes to this robot
    pub fn subscribe(&mut self, client_id: Uuid) {
        self.subscribed_clients.insert(client_id);
        // Send current state to new subscriber
    }

    /// Broadcast state change to all subscribers
    pub async fn broadcast(&self, response: ServerResponse) {
        for client_id in &self.subscribed_clients {
            // Send to client via ClientManager lookup
        }
    }
}
```

---

## ğŸ“… Implementation Phases

### Phase 1: Simulator & Execution Fixes (Critical)
- [ ] Fix simulator pause/abort to be immediate
- [ ] Implement FRC_Pause command in simulator
- [ ] Refactor ProgramExecutor for buffered streaming
- [ ] Add speed override UI

### Phase 2: Robot Connection Redesign
- [ ] Extend database schema for robot_connections
- [ ] Add io_display_config table
- [ ] Redesign Settings page
- [ ] Implement RobotSession manager

### Phase 3: Server-Side State
- [ ] Implement ClientManager with session tracking
- [ ] Move executor state to server (per-robot)
- [ ] Implement state broadcasting to clients
- [ ] Handle client disconnect/reconnect

### Phase 4: Control Locking
- [ ] Implement control lock mechanism
- [ ] Add control request/transfer flow
- [ ] Implement inactivity timeout
- [ ] Add toast notifications for control changes

### Phase 5: Complete I/O
- [ ] Add analog I/O commands to fanuc_rmi
- [ ] Add group I/O commands to fanuc_rmi
- [ ] Extend web API for all I/O types
- [ ] Implement I/O configuration UI
- [ ] Implement configurable I/O panel

---

## ğŸ”„ Migration Path

### Database Migration

```sql
-- Migration v0.7.0 â†’ v0.8.0

-- Step 1: Add new columns to robot_connections
ALTER TABLE robot_connections ADD COLUMN auto_connect BOOLEAN DEFAULT FALSE;
ALTER TABLE robot_connections ADD COLUMN is_simulator BOOLEAN DEFAULT FALSE;
ALTER TABLE robot_connections ADD COLUMN default_speed REAL DEFAULT 100.0;
ALTER TABLE robot_connections ADD COLUMN default_speed_type TEXT DEFAULT 'mm/s';
ALTER TABLE robot_connections ADD COLUMN default_term_type TEXT DEFAULT 'CNT';
ALTER TABLE robot_connections ADD COLUMN default_term_value INTEGER DEFAULT 100;
ALTER TABLE robot_connections ADD COLUMN default_uframe INTEGER DEFAULT 0;
ALTER TABLE robot_connections ADD COLUMN default_utool INTEGER DEFAULT 0;
ALTER TABLE robot_connections ADD COLUMN default_w REAL DEFAULT 0.0;
ALTER TABLE robot_connections ADD COLUMN default_p REAL DEFAULT 0.0;
ALTER TABLE robot_connections ADD COLUMN default_r REAL DEFAULT 0.0;

-- Step 2: Create io_display_config table
CREATE TABLE IF NOT EXISTS io_display_config (
    id INTEGER PRIMARY KEY,
    robot_connection_id INTEGER NOT NULL,
    io_type TEXT NOT NULL,
    port_number INTEGER NOT NULL,
    display_name TEXT,
    display_order INTEGER DEFAULT 0,
    show_in_panel BOOLEAN DEFAULT TRUE,
    show_in_dashboard BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (robot_connection_id) REFERENCES robot_connections(id) ON DELETE CASCADE,
    UNIQUE(robot_connection_id, io_type, port_number)
);

-- Step 3: Create server_settings table
CREATE TABLE IF NOT EXISTS server_settings (
    id INTEGER PRIMARY KEY,
    key TEXT NOT NULL UNIQUE,
    value TEXT,
    description TEXT
);

-- Step 4: Migrate data from robot_settings to default robot_connection
-- (Handle manually or prompt user on first run)
```

---

## âœ… Acceptance Criteria

### Pause/Abort
- [ ] Clicking "Pause" stops robot motion within 100ms
- [ ] Clicking "Stop" aborts all motion and clears queue
- [ ] Pause works mid-motion (not just between instructions)

### Buffered Execution
- [ ] Program sends instructions 5 at a time (not all at once)
- [ ] Progress tracks actual completed instructions
- [ ] Pause prevents new instructions from being sent
- [ ] Resume continues from where it paused

### Speed Override
- [ ] Slider changes robot speed in real-time
- [ ] Current override percentage displayed
- [ ] Works during program execution

### Robot Connections
- [ ] Can configure multiple robot connections
- [ ] Can switch between connections without losing configuration
- [ ] Per-robot motion defaults are applied

### Control Locking
- [ ] Only one client can send motion commands at a time
- [ ] Other clients can observe but not control
- [ ] 10-minute inactivity timeout releases control
- [ ] Toast notification when control changes

### I/O
- [ ] All I/O types (DIN/DOUT/AIN/AOUT/GIN/GOUT) work
- [ ] I/O points can be named and configured per-robot
- [ ] Right panel shows configured subset
- [ ] Dashboard shows full I/O grid

---

## ğŸ“š References

- FANUC RMI Manual B-84184EN_02
- Current codebase: `fanuc_rmi/`, `web_server/`, `web_app/`, `sim/`
- Related docs: `docs/RMI_COMMANDS_REFERENCE.md`, `docs/FANUC_ROBOTICS_FUNDAMENTALS.md`

